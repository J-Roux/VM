#include "vm.h"

typedef enum
{
	INSTRUCTION,
	ARG,
	EXEC,
	DATA,
	TERMINATE
}STATE;

STATE state = ARG;
uint16_t arg;


#define TYPE_COMPARE_BINARY_OPERATION(OPERATION, TYPE, SIZE, OP ) case OPERATION: \
{\  
TYPE op1, op2; \
pop_##SIZE(&op1); \
pop_##SIZE(&op2); \
push_byte(op1 OP op2); \
break;\
}


#define TYPE_BINARY_OPERATION(OPERATION, TYPE, SIZE, OP ) case OPERATION: \
{\  
TYPE op1, op2; \
pop_##SIZE(&op1); \
pop_##SIZE(&op2); \
push_##SIZE(op1 OP op2); \
break;\
}



#define UNSIGNED_COMPARE_BINARY_OPERATION(OPERATION, OP) TYPE_COMPARE_BINARY_OPERATION(OPERATION##_BYTE, uint8_t, byte, OP) \
TYPE_COMPARE_BINARY_OPERATION(OPERATION##_SHORT, uint16_t, short, OP) \
TYPE_COMPARE_BINARY_OPERATION(OPERATION##_INT, uint32_t, int, OP) \
TYPE_COMPARE_BINARY_OPERATION(OPERATION##_LONG, uint64_t, long, OP) 

#define SIGNED_COMPARE_BINARY_OPERATION(OPERATION, OP) TYPE_COMPARE_BINARY_OPERATION(OPERATION##_SBYTE, int8_t, byte, OP) \
TYPE_COMPARE_BINARY_OPERATION(OPERATION##_SSHORT, int16_t, short, OP) \
TYPE_COMPARE_BINARY_OPERATION(OPERATION##_SINT, int32_t, int, OP) \
TYPE_COMPARE_BINARY_OPERATION(OPERATION##_SLONG, int64_t, long, OP) 

#define UNSIGNED_BINARY_OPERATION(OPERATION, OP) TYPE_BINARY_OPERATION(OPERATION##_BYTE, uint8_t, byte, OP) \
TYPE_BINARY_OPERATION(OPERATION##_SHORT, uint16_t, short, OP) \
TYPE_BINARY_OPERATION(OPERATION##_INT, uint32_t, int, OP) \
TYPE_BINARY_OPERATION(OPERATION##_LONG, uint64_t, long, OP) 

#define SIGNED_BINARY_OPERATION(OPERATION, OP) TYPE_BINARY_OPERATION(OPERATION##_SBYTE, int8_t, byte, OP) \
TYPE_BINARY_OPERATION(OPERATION##_SSHORT, int16_t, short, OP) \
TYPE_BINARY_OPERATION(OPERATION##_SINT, int32_t, int, OP) \
TYPE_BINARY_OPERATION(OPERATION##_SLONG, int64_t, long, OP) 

#define BINARY_OPERATION(OPERATION, OP) \
UNSIGNED_BINARY_OPERATION(OPERATION, OP)\
SIGNED_BINARY_OPERATION(OPERATION, OP)
        
#define COMPARE_BINARY_OPERATION(OPERATION, OP) \
UNSIGNED_COMPARE_BINARY_OPERATION(OPERATION, OP) \
SIGNED_COMPARE_BINARY_OPERATION(OPERATION, OP) 

#define TYPE_UNARY_OPERATION(OPERATION, TYPE, SIZE, OP ) case OPERATION: \
{\  
TYPE op1; \
pop_##SIZE(&op1); \
push_##SIZE(OP op1); \
break;\
}

#define UNSIGNED_UNARY_OPERATION(OPERATION, OP) TYPE_UNARY_OPERATION(OPERATION##_BYTE, uint8_t, byte, OP) \
TYPE_UNARY_OPERATION(OPERATION##_SHORT, uint16_t, short, OP) \
TYPE_UNARY_OPERATION(OPERATION##_INT, uint32_t, int, OP) \
TYPE_UNARY_OPERATION(OPERATION##_LONG, uint64_t, long, OP) 

#define SIGNED_UNARY_OPERATION(OPERATION, OP) TYPE_UNARY_OPERATION(OPERATION##_SBYTE, int8_t, byte, OP) \
TYPE_UNARY_OPERATION(OPERATION##_SSHORT, int16_t, short, OP) \
TYPE_UNARY_OPERATION(OPERATION##_SINT, int32_t, int, OP) \
TYPE_UNARY_OPERATION(OPERATION##_SLONG, int64_t, long, OP) 

#define UNARY_OPERATION(OPERATION, OP) \
UNSIGNED_UNARY_OPERATION(OPERATION, OP)\
SIGNED_UNARY_OPERATION(OPERATION, OP)
        
RESULT execute_intruction(uint8_t *code, uint16_t *program_counter, uint16_t programm_size)
{
	RESULT result = SUCCESS;
	COMMANDS command = code[*program_counter];
	switch (command)
	{
            BINARY_OPERATION(ADD, +);
            BINARY_OPERATION(SUB, -);
            BINARY_OPERATION(MUL, *);
            BINARY_OPERATION(DIV, /);
            UNSIGNED_BINARY_OPERATION(OR, |);
            UNSIGNED_BINARY_OPERATION(AND, &);
            UNSIGNED_BINARY_OPERATION(SHR, >>);
            UNSIGNED_BINARY_OPERATION(SHL, <<);
            UNSIGNED_COMPARE_BINARY_OPERATION(EQ, ==);
            UNSIGNED_COMPARE_BINARY_OPERATION(NEQ, !=);
            COMPARE_BINARY_OPERATION(LT, <);
            COMPARE_BINARY_OPERATION(GT, >);
            COMPARE_BINARY_OPERATION(LEQ, <=);
            COMPARE_BINARY_OPERATION(GEQ, >=);
 	          UNARY_OPERATION(INC, ++);
            UNARY_OPERATION(DEC, --);
            SIGNED_UNARY_OPERATION(NEG, -);
            UNSIGNED_UNARY_OPERATION(NOT, ~);
 	}
	
	return result;
}

RESULT execute_step(uint8_t *code, uint16_t *program_counter, uint16_t programm_size)
{
	RESULT result = SUCCESS;
	switch (state)
	{
	case INSTRUCTION:
	{
		result = execute_intruction(code, program_counter, programm_size);
		break;
	}
	case ARG:
	{
		if (*program_counter + 2 < programm_size)
		{
			arg = *(uint16_t*)code;
			*program_counter += 2;
			result = SUCCESS;
		}
		else
			result = CODE_END;
		break;
	}
	

	case DATA:
		break;

	case TERMINATE:
		break;
	}
	return result;
}
